import os
import random
import re
import asyncio
import httpx
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import (
    ApplicationBuilder, ContextTypes, MessageHandler, CallbackQueryHandler,
    CommandHandler, filters
)

load_dotenv()
generated_cache = {}
bin_cache = {}

def luhn_checksum(card_number: str) -> int:
    digits = [int(d) for d in card_number]
    checksum = 0
    is_even = True
    for d in reversed(digits):
        if is_even:
            d *= 2
            if d > 9:
                d -= 9
        checksum += d
        is_even = not is_even
    return (10 - checksum % 10) % 10

def generate_cc_full(bin_code, exp_month=None, exp_year=None):
    rand_len = 15 - len(bin_code)
    base = bin_code + ''.join(str(random.randint(0, 9)) for _ in range(rand_len))
    cc = base + str(luhn_checksum(base))
    month = exp_month or f"{random.randint(1, 12):02d}"
    year = exp_year or str(random.randint(2025, 2032))
    cvv = f"{random.randint(0, 999):03d}"
    return f"{cc}|{month}|{year}|{cvv}"

def generate_txt(data):
    return "\n".join(data).encode('utf-8')

def generate_csv(data):
    header = "CC Number,Expiry Month,Expiry Year,CVV\n"
    rows = ["".join(item.split("|")) for item in data]
    return (header + "\n".join(rows)).encode('utf-8')

async def fetch_bin_info(bin_code: str) -> dict:
    if bin_code in bin_cache:
        return bin_cache[bin_code]

    try:
        async with httpx.AsyncClient(timeout=5) as client:
            res = await client.get(f"https://lookup.binlist.net/{bin_code}")
            if res.status_code == 200:
                data = res.json()
                info = {
                    "scheme": data.get("scheme", "Unknown").capitalize(),
                    "type": data.get("type", "Unknown").capitalize(),
                    "brand": data.get("brand", "Unknown"),
                    "bank": data.get("bank", {}).get("name", "Unknown"),
                    "country": data.get("country", {}).get("name", "Unknown"),
                    "emoji": data.get("country", {}).get("emoji", "")
                }
                bin_cache[bin_code] = info
                return info
    except Exception as e:
        print(f"BIN lookup failed: {e}")

    return {
        "scheme": "Unknown",
        "type": "Unknown",
        "brand": "Unknown",
        "bank": "Unknown",
        "country": "Unknown",
        "emoji": ""
    }

async def handle_gen(update: Update, context: ContextTypes.DEFAULT_TYPE, command_mode=False):
    if command_mode:
        text = " ".join(context.args)
    else:
        text = update.message.text

    bin_match = re.search(r"(?:\.gen|/gen)?\s*(\d{6,15})", text)
    count_match = re.search(r"x(\d{1,3})", text)
    exp_match = re.search(r"exp=(\d{2})\|(\d{4})", text)

    if not bin_match:
        await update.message.reply_text("⚠️ Usage: `/gen <bin> x<qty> exp=MM|YYYY`", parse_mode="Markdown")
        return

    bin_code = bin_match.group(1)
    count = min(int(count_match.group(1)) if count_match else 1, 50)
    exp_month, exp_year = (exp_match.group(1), exp_match.group(2)) if exp_match else (None, None)

    results = [generate_cc_full(bin_code, exp_month, exp_year) for _ in range(count)]
    generated_cache[update.effective_chat.id] = results

    bin_info = await fetch_bin_info(bin_code)
    brand = bin_info["scheme"]
    bank = bin_info["bank"]
    country = f"{bin_info['country']} {bin_info['emoji']}"
    card_type = bin_info["type"]

    card_list = "\n".join(results)

    keyboard = [[
        InlineKeyboardButton("⬇️ Export .txt", callback_data='export_txt'),
        InlineKeyboardButton("⬇️ Export .csv", callback_data='export_csv')
    ]]

    await update.message.reply_text(
        f"💳 *Issuer:* {brand}\n"
        f"🏦 *Bank:* {bank}\n"
        f"🌍 *Country:* {country}\n"
        f"📦 *Type:* {card_type}\n"
        f"🔢 *Generated {len(results)} Cards:*\n"
        f"```\n{card_list}\n```\n"
        f"Generated by @revgenbot",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_bin(update: Update, context: ContextTypes.DEFAULT_TYPE, command_mode=False):
    if command_mode:
        text = " ".join(context.args)
    else:
        text = update.message.text

    bin_match = re.search(r"(?:\.bin|/bin)?\s*(\d{6,15})", text)
    if not bin_match:
        await update.message.reply_text("⚠️ Usage: `/bin <6-15 digit BIN>`", parse_mode="Markdown")
        return

    bin_code = bin_match.group(1)
    bin_info = await fetch_bin_info(bin_code)

    await update.message.reply_text(
        f"🔍 *BIN Lookup:* `{bin_code}`\n"
        f"💳 *Scheme:* {bin_info['scheme']}\n"
        f"🏦 *Bank:* {bin_info['bank']}\n"
        f"🌍 *Country:* {bin_info['country']} {bin_info['emoji']}\n"
        f"💼 *Type:* {bin_info['type']}\n"
        f"🏷 *Brand:* {bin_info['brand']}\n"
        f"\nGenerated by @revgenbot",
        parse_mode="Markdown"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.lower()
    if text.startswith(".gen"):
        await handle_gen(update, context)
    elif text.startswith(".bin"):
        await handle_bin(update, context)

async def export_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = generated_cache.get(query.message.chat.id)
    if not data:
        await query.edit_message_text("❌ No recent generation found.")
        return

    if query.data == 'export_txt':
        file_data, name = generate_txt(data), "cards.txt"
    else:
        file_data, name = generate_csv(data), "cards.csv"

    await context.bot.send_document(chat_id=query.message.chat.id, document=InputFile(file_data, name))

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "👋 Welcome to @revgenbot — the card generator!\n\n"
        "Use `/gen <bin> x<qty> exp=MM|YYYY` to generate cards.\n\n"
        "*Examples:*\n"
        "`/gen 457821`\n"
        "`/gen 457821 x5`\n"
        "`/gen 457821 x10 exp=07|2030`\n\n"
        "Or simply type:\n"
        "`.gen 457821`",
        parse_mode="Markdown"
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "📘 *How to use @revgenbot:*\n\n"
        "`/gen <bin>` - Generate 1 card\n"
        "`/gen <bin> x10` - Generate 10 cards\n"
        "`/gen <bin> x5 exp=08|2030` - Cards with expiry date\n"
        "`.gen <bin>` also works from normal messages.\n\n"
        "`/bin <bin>` or `.bin <bin>` - Lookup BIN details.",
        parse_mode="Markdown"
    )

async def main():
    token = os.getenv("BOT_TOKEN")
    if not token:
        print("❌ BOT_TOKEN is missing in environment variables.")
        return

    app = ApplicationBuilder().token(token).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("gen", lambda u, c: handle_gen(u, c, command_mode=True)))
    app.add_handler(CommandHandler("bin", lambda u, c: handle_bin(u, c, command_mode=True)))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(CallbackQueryHandler(export_callback))

    print("✅ Bot is running...")
    await app.run_polling()

# --- Entry Point for Railway/async fix ---
import nest_asyncio
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError:
        nest_asyncio.apply()
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())
